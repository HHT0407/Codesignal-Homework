# 流程圖
<img src='https://github.com/HHT0407/Codesignal-Homework/blob/master/Dijkstra.jfif' height=400 weight =400>

# 原理說明
迪傑斯特拉（Dijkstra）算法是一個按照路徑長度遞增的次序產生的最短路徑算法。下圖為帶權值的有向圖，作為程序中的實驗數據。


其中，帶權值的有向圖採用鄰接矩陣graph來進行存儲，在計算中就是採用n*n的二維數組來進行存儲，v0-v5表示數組的索引編號0-5，二維數組的值表示節點之間的權值，若兩個節點不能通行，比如，v0->v1不能通行，那麼$graph[0,1]=\infty$ （採用計算機中最大正整數來進行表示）。那如何求解從v0每個v節點的最短路徑長度呢?


首先，引進一個輔助數組cost，它的每個值$cost[i]$表示當前所找到的從起始點v0到終點vi的最短路徑的權值（長度花費），該數組的初態為：若從v0到vi有弧，則$cost[i]$為弧上的權值，否則置$cost[i]$為$\infty$ 。顯然，長度為：


cost[j]=Min_i(graph[0,i] | v_i \in V)


的路徑就是從v0齣發的長度最短的一條最短路徑。此路徑為$(v_0,v_j)$ ，那麼下次長度次短的路徑必定是弧$(v_0,v_i)$ 上的權值$cost[i](v_i \in V)$，或者是$cost[k](v_k \in S)$ 和弧$(v_k,v_i)$ 的權值之和。其中V：待求解最短路徑的節點j集合；S：已求解最短路徑的節點集合。

其實迪傑斯特拉（Dijkstra）最短路徑算法是上一篇文迷宮問題求解之「A*搜索」（二）所講到的 A*搜索算法中的一個特例，當A *搜索算法中 h(n)函數為0的時候，那麼它就是迪傑斯特拉算法，算法原理一樣，只不過在寫程序的時候稍微有點區別而已。

2 算法流程
根據上面的算法原理分析，下面描述算法的實現流程。

初始化：初始化輔助數組cost，從v0齣發到圖上其餘節點v的初始權值為：$cost[i]=graph[0,i] \ |\ v_i \in V$ ；初始化待求節點S集合，它的初始狀態為空集。

選擇節點$v_j$ ，使得$cost[j]=Min ( cost[i] | v_i \in V -S )$ ，$v_j$ 就是當前求的一條從v0齣發的最短路徑的終點，修改S集合，使得$S=S\bigcup V_j$ 。

修改從v0齣發到節點V-S上任一頂點$v_k$ 可達的最短路徑，若cost[j]+graph[j,k]<cost[k] ，則修改cost[k]為：cost[k]=cost[j]+graph[j,k] 。

重複操作2，3步驟，直到求解集合V中的所有節點為止。

其中最短路徑的存儲採用一個path整數數組，path[i]的值記錄vi的前一個節點的索引，通過path一直追溯到起點，就可以找到從vi到起始節點的最短路徑。比如起始節點索引為0，若path[3]=4, path[4]=0；那麼節點v2的最短路徑為，v0->v4->v3。

# 學習歷程 這一次的功課程式碼的部分已經超出我個人能力範圍，但是尚可理解，所以程式碼的部分用參考作為替代。

# 參考資料: 原文網址 https://kknews.cc/code/zj3g6l.html
